API: https://client.vpn.nuist.edu.cn/https/webvpn893ff9021738b0357186c0f23fc2aed6e24ca283e886022bc5d861ea12f03963/v1/problem/logic?prefix=b&logicId=3689&enlink-vpn

#### 题目描述

给定n个非负整数A\[1\], A\[2\], ……, A\[n\]。  
对于每对(i, j)满足1 <= i < j <= n，得到一个新的数A\[i\] xor A\[j\]，这样共有n\*(n-1)/2个新的数。求这些数（不包含A\[i\]）中前k小的数。  
注：xor对应于pascal中的“xor”，C++中的“^”。  

---

#### 输入格式

第一行2个正整数 n,k，如题所述。  
以下n行，每行一个非负整数表示A\[i\]。  

---

#### 输出格式

 共一行k个数，表示前k小的数。  

---

#### 样例输入
```
4 5
1
1
3
4

```

---

#### 样例输出
```
0 2 2 5 5

```

---

#### 提示

【样例解释】  
1 xor 1 = 0 (A\[1\] xor A\[2\])  
1 xor 3 = 2 (A\[1\] xor A\[3\])  
1 xor 4 = 5 (A\[1\] xor A\[4\])  
1 xor 3 = 2 (A\[2\] xor A\[3\])  
1 xor 4 = 5 (A\[2\] xor A\[4\])  
3 xor 4 = 7 (A\[3\] xor A\[4\])  
前5小的数：0 2 2 5 5  
【数据范围】  
 对于100%的数据，2 <= n <= 100000； 1 <= k <= min{250000, n\*(n-1)/2}；  
        0 <= A\[i\] < 2^31  

---

#### 题目来源

没有写明来源